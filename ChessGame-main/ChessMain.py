# John (Jack) Mismash
# 5/7/2021

# This ChessMain file will display the current game state and handle any user input.

import pygame as p
import ChessEngine
import ChessAI


# Width/Height of the chess board.
# Resolution can be set to higher with a Width/Height of 400.
WIDTH = HEIGHT = 512

# Dimensions of a chess board are 8x8.
DIMENSION = 8

# Each individual Square size with floor division.
SQUARE_SIZE = HEIGHT // DIMENSION

# Maximum FPS for animation of the pieces.
MAX_FPS = 15

# Dictionary of Images for the Chess game.
IMAGES = {}

# Initialize our pyGame globally, so no methods will rely on this anywhere else in the program.
p.init()

global squareColors


# Initialize the dictionary of Images. We can now access any piece image with IMAGES['WP']
# for example and each string is represented as the key in our dictionary.
def loadPieceImages():
    piece_images = ['WP', 'WR', 'WN', 'WB', 'WQ', 'WK', 'BP', 'BR', 'BN', 'BB', 'BQ', 'BK']

    # Loads each piece image into our global dictionary of pieces. This will also scale each image to
    # the respective square size of our board.
    for piece in piece_images:
        IMAGES[piece] = p.transform.scale(p.image.load("Chess/Pieces/" + piece + ".png"),
                                          (SQUARE_SIZE, SQUARE_SIZE))


# This is the main driver for the Chess Game and handle any user input and updating the display of the game
# and its respective graphics.
def main():
    # Creates a console with the specific width and height.
    console = p.display.set_mode((WIDTH, HEIGHT))

    # Create a clock that will run to check for events.
    gameClock = p.time.Clock()

    console.fill(p.Color("white"))

    # Create a "blank" game state that will allow for all the pieces to be in their
    # respective starting position.
    gameState = ChessEngine.ChessGame()

    # Returns a list of valid moves at the beginning of the game.
    validMoves = gameState.getValidMovesNaive()

    # Flag variable for when a move is made.
    moveMade = False

    animate = False

    # Load the images into the global variable so they are accessible. This is only called once
    # in the program.
    loadPieceImages()

    # Checks if the console has been closed.
    gameIsRunning = True

    currentSquare = ()
    selectedSquares = []

    # Draw the initial game board and pieces.
    drawGame(console, gameState, validMoves, currentSquare)

    gameOver = False

    # True if human is playing white, False if AI is playing white.
    playerOne = False

    # True is human is playing black, False if AI is playing black.
    playerTwo = False

    while gameIsRunning:
        isHumanTurn = (gameState.whiteToMove and playerOne) or (not gameState.whiteToMove and playerTwo)

        for event in p.event.get():
            if event.type == p.QUIT:
                gameIsRunning = False

            # If there is a event where a mouse is clicked, we can capture the (x, y)
            # coordinates of where the mouse was clicked.
            elif event.type == p.MOUSEBUTTONDOWN:
                if not gameOver and isHumanTurn:
                    clickLocation = p.mouse.get_pos()

                    # Since our x,y coordinates are now stored in an array, we can access this array and capture the row
                    # and column respective to where they clicked.
                    # NOTE: Each row and column will start at zero, unlike a representation of an actual chess board.
                    click_column = clickLocation[0] // SQUARE_SIZE
                    click_row = clickLocation[1] // SQUARE_SIZE

                    # If the piece has already been selected, we do not want to say this is a valid move,
                    # so we can set our selected square variable to be empty to signify a deselection of the piece.
                    # Otherwise, we can update the current square that has been selected as normal.
                    if currentSquare != (click_row, click_column):
                        currentSquare = (click_row, click_column)

                        # Keeps track of the first and second clicks that a player makes.
                        selectedSquares.append(currentSquare)

                    else:
                        currentSquare = ()
                        selectedSquares = []

                    # If the user has made a valid second click to a new square, we want to now
                    # perform this valid move within the Chess game.
                    if len(selectedSquares) == 2:
                        move = ChessEngine.Move(selectedSquares[0], selectedSquares[1], gameState)

                        for i in range(len(validMoves)):
                            if move == validMoves[i]:
                                # Allows the game to process the move generated by the engine, not the player.
                                gameState.processMove(validMoves[i])
                                moveMade = True
                                animate = True

                                currentSquare = ()
                                selectedSquares = []

                        # Assumes that a second selection of a piece is a deselection.
                        if not moveMade:
                            selectedSquares = [currentSquare]

            elif event.type == p.KEYDOWN:
                # When the 'z' key is pressed, undo the move.
                if event.key == p.K_z:
                    gameState.undoMove()
                    moveMade = True
                    animate = False

                # When the 'r' key is pressed, reset the game.
                if event.key == p.K_r:
                    gameState = ChessEngine.ChessGame()
                    validMoves = gameState.getValidMovesNaive()
                    currentSquare = ()
                    selectedSquares = []
                    moveMade = False
                    animate = False

        # Let AI find next move.
        if not gameOver and not isHumanTurn:
            move = ChessAI.findRandomMove(validMoves)
            gameState.processMove(move)
            moveMade = True
            animate = True

        # If a move was just made, we now want to update the list of possible valid moves.
        if moveMade:
            if animate:
                animateMove(console, gameState.moveLog[-1], gameState, gameClock)

            validMoves = gameState.getValidMovesNaive()
            moveMade = False

        drawGame(console, gameState, validMoves, currentSquare)

        if gameState.checkmate:
            gameOver = True

            if gameState.whiteToMove:
                drawText(console, "Black wins by checkmate!")
            else:
                drawText(console, "White wins by checkmate!")

        elif gameState.stalemate:
            gameOver = True

            drawText(console, "Draw by stalemate!")

        gameClock.tick(MAX_FPS)
        p.display.flip()


def highlightSquares(console, gameState, validMoves, sqSelected):
    if sqSelected != ():
        row, column = sqSelected

        # Validate that the piece selected is a piece that can be moved.
        if gameState.ChessBoard[row][column][0] == ('W' if gameState.whiteToMove else 'B'):
            s = p.Surface((SQUARE_SIZE, SQUARE_SIZE))

            # Set transparency value.
            s.set_alpha(100)

            # Set square color.
            s.fill(p.Color('blue'))
            console.blit(s, (column * SQUARE_SIZE, row * SQUARE_SIZE))

            # Highlight available moves from that square.
            s.fill(p.Color('yellow'))
            for move in validMoves:
                if move.startRow == row and move.startColumn == column:
                    console.blit(s, (move.endColumn * SQUARE_SIZE, move.endRow * SQUARE_SIZE))


# This will draw everything to the console, including the squares and the pieces.
def drawGame(console, gameState, validMoves, highlightedSquare):
    drawBoard(console)
    highlightSquares(console, gameState, validMoves, highlightedSquare)
    drawPieces(console, gameState.ChessBoard)


# This will draw the squares of the Chess Board.
def drawBoard(console):
    # These colors may be changed to be any color scheme of the users choice.
    global squareColors
    squareColors = [p.Color("white"), p.Color("gray")]

    # We know that every board setup will always have a "light" square in the top left corner,
    # regardless of the perspective of white/black.

    # We can also set up our squareColors to that the access to a light color is at the 0 index, and the access
    # to a dark color is the 1 index.
    for row in range(DIMENSION):
        for column in range(DIMENSION):
            # When we add the row and column number and mod by 2, we will know whether that
            # position should be a light or dark square if there is a remainder or not, and we can use this
            # remainder of 0 or 1 to access our colors.
            squareColor = squareColors[(row + column) % 2]

            # Draw the square given the respective position and color.
            p.draw.rect(console, squareColor, (column * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))


# This will draw the initial setup of the pieces on the board.
def drawPieces(console, ChessBoard):
    # Since we know the initial setup of the board, we can access each piece on the board, and draw the
    # respective piece image.
    for row in range(DIMENSION):
        for column in range(DIMENSION):
            piece = ChessBoard[row][column]

            if piece != "--":
                piece_image = IMAGES[piece]
                console.blit(piece_image, p.Rect(column * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))


def animateMove(console, move, gameState, clock):
    global squareColors

    deltaRow = move.endRow - move.startRow
    deltaColumn = move.endColumn - move.startColumn

    # Frames to move one square.
    framesPerSquare = 10
    frameCount = framesPerSquare * (abs(deltaRow) + abs(deltaColumn))

    for frame in range(frameCount + 1):
        row, column = (move.startRow + deltaRow * frame / frameCount,
                       move.startColumn + deltaColumn * frame / frameCount)

        drawBoard(console)
        drawPieces(console, gameState.ChessBoard)
        color = squareColors[((move.endRow + move.endColumn) % 2)]
        endSquare = p.Rect(move.endColumn * SQUARE_SIZE, move.endRow * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)
        p.draw.rect(console, color, endSquare)

        if move.capturedPiece != "--":
            console.blit(IMAGES[move.capturedPiece], endSquare)

        # Draw moving piece.
        console.blit(IMAGES[move.movedPiece], p.Rect(column * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
        p.display.flip()
        clock.tick(60)


def drawText(console, message):
    font = p.font.SysFont("Helvetica", 32, True, False)
    textObj = font.render(message, 0, p.Color("Black"))
    textLocation = p.Rect(0, 0, WIDTH, HEIGHT).move(WIDTH / 2 - textObj.get_width() / 2,
                                                    HEIGHT / 2 - textObj.get_height() / 2)
    console.blit(textObj, textLocation)

    textObj = font.render(message, 0, p.Color("Red"))
    console.blit(textObj, textLocation.move(2, 2))


if __name__ == "__main__":
    main()
